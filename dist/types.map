{"version":3,"sources":["types.js"],"names":["isNotNull","x","NaN","isType","v","name","isFunction","isObject","isString","isNumber","isBoolean","isArray","Array","throwError","TypeError","e","trace","log","msg","Pipe","fn","hasFields","fields","obj","filter","hasOwnProperty","f","length","toObject","key","value","Object","assign","setPrototype","setPrototypeOf","proto","Type","typecheck","constructor","val","andThen","is","prototype","constuctor","check","of","toString","StringType","String","ObjectType","NumberType","Number","BooleanType","Boolean","ArrayType","typeMap","getTypecheckedCounterpart","undefined","normalizeDefinition","entries","def","map","typeConstructor","reduce","isValidDataDefinition","typecheckData","keys","typeDef","constructData","data","Data","isValidUnionDefinition","values","d","caseOf","match","type","opts","Union","create","AnyType","NothingType","Maybe","SuccessType","ok","ErrorType","error","Result","EmailRegEx","EmailType","test","module","exports"],"mappings":"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","file":"types.map","sourceRoot":"../src","sourcesContent":["/*\n    type.js\n\n    TODO: Make types immutable\n*/\n\n//\n// -- Helpers --\n//\n\nconst isNotNull = x => x !== undefined && x !== null && x !== NaN\nconst isType = name => v => isNotNull(v) && typeof v === name\nconst isFunction = isType('function')\nconst isObject = isType('object')\nconst isString = isType('string')\nconst isNumber = isType('number')\nconst isBoolean = isType('boolean')\nconst isArray = Array.isArray\n\nconst throwError = e => {\n    throw new TypeError(e)\n}\nconst trace = msg => v => {\n    console.log(msg, v)\n    return v\n}\nconst Pipe = x => ({\n    andThen: fn => Pipe(fn(x)),\n    value: () => x\n})\n\nconst hasFields = (fields, obj) =>\n    isObject(obj) && isArray(fields)\n        ? fields.filter(f => !obj.hasOwnProperty(f)).length === 0\n        : false\nconst toObject = (obj, [key, value]) =>\n    Object.assign(obj, {\n        [key]: value\n    })\nconst setPrototype = proto => obj => {\n    // TODO: Replace with Object.create() because setPrototypeOf can have a\n    //       serious performance impact.\n    if (isNotNull(obj)) {\n        Object.setPrototypeOf(obj, proto)\n    }\n    // obj.prototype = Object.create(proto)\n    return obj\n}\n\n//\n// -- Type Type --\n//\n\n//\n// Find a way of freezing objects to make them immutable. Maybe use:\n// seamless-immutable..?\n//\n// Type :: String -> Fn -> (a -> a)\nconst Type = (name, typecheck, constructor = x => x) => {\n    const obj = {\n        [name]: function(val) {\n            return Pipe(constructor(val))\n                .andThen(\n                    v =>\n                        typecheck(v)\n                            ? v\n                            : throwError(\n                                  `Value '${val}' is not of expected type '${name}'`\n                              )\n                )\n\n                .andThen(setPrototype({ constructor: obj[name] }))\n                .value()\n        }\n    }\n    // Constructor typecheck?\n    obj[name].is = v =>\n        isNotNull(v) && v.prototype && v.prototype.constructor\n            ? v.prototype.constuctor === obj[name]\n            : typecheck(v)\n    obj[name].check = x =>\n        obj[name].is(x)\n            ? x\n            : throwError(\"Check: Failed: Expect type '\" + name + \"'\")\n    obj[name].of = x => Type(name, v => obj[name].is(v) && v === x, () => x)\n    obj[name].toString = () => name + '(x)'\n    // obj[name].inspect = () => name + '(x)'\n    return obj[name]\n}\n\n//\n// -- JS Type Replacements --\n//\n\nconst StringType = Type('String', isString, String)\nconst ObjectType = Type('Object', isObject, Object)\nconst NumberType = Type('Number', isNumber, Number)\nconst BooleanType = Type('Boolean', isBoolean, Boolean)\nconst ArrayType = Type('Boolean', Array.isArray, Array)\n\nconst typeMap = {}\ntypeMap[String] = StringType\ntypeMap[Object] = ObjectType\ntypeMap[Number] = NumberType\ntypeMap[Boolean] = BooleanType\ntypeMap[Array] = ArrayType\n\n// const replaceWithTypecheckedVersion = constructor =>\nconst getTypecheckedCounterpart = constructor =>\n    typeMap[constructor] !== undefined ? typeMap[constructor] : constructor\n\n//\n// -- Data Type --\n//\n\nconst normalizeDefinition = def =>\n    // Replace default type constructor (eg. String) with our typechecked\n    // counterparts.\n    Object.entries(def)\n        .map(([name, typeConstructor]) => [\n            name,\n            isObject(typeConstructor)\n                ? normalizeDefinition(typeConstructor)\n                : getTypecheckedCounterpart(typeConstructor)\n        ])\n        .reduce(toObject, {})\n\n// Every object is a valid definition\nconst isValidDataDefinition = isObject\n\n// Structural typecheck\nconst typecheckData = typeDef => val =>\n    isObject(val) &&\n    hasFields(Object.keys(typeDef), val) &&\n    // Filter out all keys that pass the typecheck\n    Object.entries(typeDef).filter(([key, type]) => !type.is(val[key]))\n        .length === 0\n\nconst constructData = typeDef => data =>\n    Object.entries(typeDef)\n        .map(([key, typeConstructor]) => [key, typeConstructor(data[key])])\n        .reduce(toObject, {})\n\n//\n//\n//\n// Data :: (String, Object) => Constructor\nconst Data = (name, typeDef) =>\n    // 1. Check if we have a valid data type definition\n    // 2. Create a constructor out of the type definition.\n    isValidDataDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Type(name, typecheckData(def), constructData(def))\n              )\n              .value()\n        : throwError(\n              'Data: Type definition must consist only of functions and objects containing functions'\n          )\n\n//\n// -- Union Type --\n//\n\nconst isValidUnionDefinition = def =>\n    // Filter out all functions. Everything that's left is unwanted.\n    Object.values(def).filter(d => !isFunction(d)).length === 0\n\nconst caseOf = (typeDef, val) => opts => {\n    const match = Object.entries(typeDef)\n        .filter(([name, type]) => type.is(val))\n        .map(([name, type]) => name)\n    const name = match[0]\n    const fn = opts[name]\n    return !!fn ? fn(val) : throwError(`${name} is not in the object!`)\n}\n\n// Union ::\nconst Union = (name, typeDef) =>\n    // Check if typedef just containing functions\n    isValidUnionDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Object.entries(def)\n                      .map(([name, type]) => [name, Type(name, type.is, type)])\n                      .reduce(\n                          toObject,\n                          Object.create({\n                              toString: () => name,\n                              is: x =>\n                                  Object.values(def).filter(type => type.is(x))\n                                      .length > 0,\n                              check(x) {\n                                  return this.is(x)\n                                      ? x\n                                      : throwError(\n                                            \"Check: Failed: Expect type '\" +\n                                                name +\n                                                \"'\"\n                                        )\n                              },\n                              case: (v, opts) => caseOf(def, v)(opts)\n                          })\n                      )\n              )\n              //   .andThen(Object.freeze)\n              .value()\n        : // wrong type definition\n          throwError('Union: Type definition must consist only of functions')\n\n//\n// -- Maybe Type --\n//\n\nconst AnyType = Type('Any', v => isNotNull(v))\nconst NothingType = Type('Nothing', v => !isNotNull(v), x => undefined)\n\n// const Just = Data('Any', { value: AnyType })\n// const Nothing = Data('Any', {})\n\nconst Maybe = Union('Maybe', {\n    // Just: Data('Just', { value: AnyType }),\n    // Nothing: Data('Nothing', { value: NothingType })\n    Just: AnyType,\n    Nothing: NothingType\n})\n\n//\n// -- Result Type --\n//\n\nconst SuccessType = Type(\n    'Ok',\n    v => isObject(v) && v.ok === true && AnyType.is(v.value),\n    v => ({ ok: true, value: AnyType(v) })\n)\nconst ErrorType = Type(\n    'Error',\n    v => isObject(v) && v.ok === false && StringType.is(v.error),\n    v => ({ ok: false, error: StringType(v) })\n)\nconst Result = Union('Result', {\n    Ok: SuccessType,\n    Err: ErrorType\n})\n\n//\n// -- Email Type --\n//\nconst EmailRegEx = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\nconst EmailType = Type(\n    'Email', // Name\n    x => StringType.is(x) && EmailRegEx.test(x), // Validator\n    StringType // Constructor\n)\n\n//\nmodule.exports = {\n    // Tools provided to build types\n    Type,\n    Data, // Type\n    Union,\n\n    // ADTs\n    Maybe,\n    Result,\n\n    // Types\n    StringType,\n    ObjectType,\n    NumberType,\n    BooleanType,\n    ArrayType,\n    AnyType,\n    NothingType,\n\n    // Specific Sub Types\n    EmailType\n\n    // Success: SuccessType,\n    // Error: ErrorType\n}\n\n// TODO: Need to write tests for the types!\n\n/*\n\nconst { Maybe } = require(\"./type.js\")\n\nconst j = Maybe.Just(\"Hey Ho!\")\nconst n = Maybe.Nothing()\n\nMaybe.case(j, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\nMaybe.case(n, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\n\n\nconst { Result } = require(\"./type.js\")\n\nconst a = Result.Ok({ Some: \"Data\" })\na\nconst e = Result.Err(\"Oje Oje..\")\ne\n\n\n\nconst Type = require(\"./type.js\")\n\nconst Coord = Type.Type('Coord', Type.Number.is)\nCoord.toString()\nCoord.name\nconst c = Coord(23)\nc\nCoord.is(c)\n\nconst Point = Type.Data(\"Point\", { x: Coord, y: Coord, z: Number })\nPoint.toString()\nPoint.name\nconst p = Point({ x: 1, y: 1, z: 1 })\np\nPoint.is(p)\n\nconst Space = Type.Union(\"Space\", {\n    Planet: Point,\n    SolarSystem: Point\n})\nSpace.toString()\nconst s = Space.Planet(p)\ns\ns.toString()\nSpace.is(s)\n\nSpace.case(s, {\n    Planet: (s) => \"It's a planet\",\n    SolarSystem: (s) => \"It's a solar system\"\n})\n\n// s.case({\n//     Planet: (s) => console.log(\"It's a planet\"),\n//     SolarSystem: (s) => console.log(\"It's a solar system\")\n// })\n\n\n*/\n"]}
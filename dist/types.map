{"version":3,"sources":["types.js"],"names":["isNotNull","x","NaN","isType","v","name","isFunction","isObject","isString","isNumber","isBoolean","isArray","Array","throwError","TypeError","e","trace","log","msg","Pipe","fn","hasFields","fields","obj","filter","hasOwnProperty","f","length","toObject","key","value","Object","assign","setPrototype","setPrototypeOf","proto","Type","typecheck","constructor","val","andThen","is","prototype","constuctor","toString","inspect","StringType","String","ObjectType","NumberType","Number","BooleanType","Boolean","ArrayType","typeMap","getTypecheckedCounterpart","undefined","normalizeDefinition","entries","def","map","typeConstructor","reduce","isValidDataDefinition","typecheckData","keys","typeDef","constructData","data","Data","isValidUnionDefinition","values","d","caseOf","match","type","opts","Union","create","AnyType","NothingType","Maybe","SuccessType","ok","ErrorType","error","Result","module","exports"],"mappings":"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","file":"types.map","sourceRoot":"../src","sourcesContent":["/*\n    type.js\n\n    TODO: Make types immutable\n*/\n\n//\n// -- Helpers --\n//\n\nconst isNotNull = x => x !== undefined && x !== null && x !== NaN\nconst isType = name => v => isNotNull(v) && typeof v === name\nconst isFunction = isType('function')\nconst isObject = isType('object')\nconst isString = isType('string')\nconst isNumber = isType('number')\nconst isBoolean = isType('boolean')\nconst isArray = Array.isArray\n\nconst throwError = e => {\n    throw new TypeError(e)\n}\nconst trace = msg => v => {\n    console.log(msg, v)\n    return v\n}\nconst Pipe = x => ({\n    andThen: fn => Pipe(fn(x)),\n    value: () => x\n})\n\nconst hasFields = (fields, obj) =>\n    isObject(obj) && isArray(fields)\n        ? fields.filter(f => !obj.hasOwnProperty(f)).length === 0\n        : false\nconst toObject = (obj, [key, value]) =>\n    Object.assign(obj, {\n        [key]: value\n    })\nconst setPrototype = proto => obj => {\n    // TODO: Replace with Object.create() because setPrototypeOf can have a\n    //       serious performance impact.\n    if (isNotNull(obj)) {\n        Object.setPrototypeOf(obj, proto)\n    }\n    // obj.prototype = Object.create(proto)\n    return obj\n}\n\n//\n// -- Type Type --\n//\n\n//\n// Find a way of freezing objects to make them immutable. Maybe use:\n// seamless-immutable..?\n//\n// Type :: String -> Fn -> (a -> a)\nconst Type = (name, typecheck, constructor = x => x) => {\n    const obj = {\n        [name]: function(val) {\n            return Pipe(constructor(val))\n                .andThen(\n                    v =>\n                        typecheck(v)\n                            ? v\n                            : throwError(\n                                  `Value '${val}' is not of expected type '${name}'`\n                              )\n                )\n\n                .andThen(setPrototype({ constructor: obj[name] }))\n                .value()\n        }\n    }\n    // Constructor typecheck?\n    obj[name].is = v =>\n        isNotNull(v) && v.prototype && v.prototype.constructor\n            ? v.prototype.constuctor === obj[name]\n            : typecheck(v)\n    // obj[name].is = typecheck\n    obj[name].toString = () => name + '(x)'\n    obj[name].inspect = () => name + '(x)'\n    return obj[name]\n}\n\nconst StringType = Type('String', isString, String)\nconst ObjectType = Type('Object', isObject, Object)\nconst NumberType = Type('Number', isNumber, Number)\nconst BooleanType = Type('Boolean', isBoolean, Boolean)\nconst ArrayType = Type('Boolean', Array.isArray, Array)\n\nconst typeMap = {}\ntypeMap[String] = StringType\ntypeMap[Object] = ObjectType\ntypeMap[Number] = NumberType\ntypeMap[Boolean] = BooleanType\ntypeMap[Array] = ArrayType\n\n// const replaceWithTypecheckedVersion = constructor =>\nconst getTypecheckedCounterpart = constructor =>\n    typeMap[constructor] !== undefined ? typeMap[constructor] : constructor\n\n//\n// -- Data Type --\n//\n\nconst normalizeDefinition = def =>\n    // Replace default type constructor (eg. String) with our typechecked\n    // counterparts.\n    Object.entries(def)\n        .map(([name, typeConstructor]) => [\n            name,\n            isObject(typeConstructor)\n                ? normalizeDefinition(typeConstructor)\n                : getTypecheckedCounterpart(typeConstructor)\n        ])\n        .reduce(toObject, {})\n\n// Every object is a valid definition\nconst isValidDataDefinition = isObject\n\n// Structural typecheck\nconst typecheckData = typeDef => val =>\n    isObject(val) &&\n    hasFields(Object.keys(typeDef), val) &&\n    // Filter out all keys that pass the typecheck\n    Object.entries(typeDef).filter(([key, type]) => !type.is(val[key]))\n        .length === 0\n\nconst constructData = typeDef => data =>\n    Object.entries(typeDef)\n        .map(([key, typeConstructor]) => [key, typeConstructor(data[key])])\n        .reduce(toObject, {})\n\n//\n//\n//\n// Data :: (String, Object) => Constructor\nconst Data = (name, typeDef) =>\n    // 1. Check if we have a valid data type definition\n    // 2. Create a constructor out of the type definition.\n    isValidDataDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Type(name, typecheckData(def), constructData(def))\n              )\n              .value()\n        : throwError(\n              'Data: Type definition must consist only of functions and objects containing functions'\n          )\n\n//\n// -- Union Type --\n//\n\nconst isValidUnionDefinition = def =>\n    // Filter out all functions. Everything that's left is unwanted.\n    Object.values(def).filter(d => !isFunction(d)).length === 0\n\nconst caseOf = (typeDef, val) => opts => {\n    const match = Object.entries(typeDef)\n        .filter(([name, type]) => type.is(val))\n        .map(([name, type]) => name)\n    const name = match[0]\n    const fn = opts[name]\n    return !!fn ? fn(val) : throwError(`${name} is not in the object!`)\n}\n\n// Union ::\nconst Union = (name, typeDef) =>\n    // Check if typedef just containing functions\n    isValidUnionDefinition(typeDef)\n        ? Pipe(normalizeDefinition(typeDef))\n              .andThen(def =>\n                  Object.entries(def)\n                      .map(([name, type]) => [name, Type(name, type.is, type)])\n                      .reduce(\n                          toObject,\n                          Object.create({\n                              toString: () => name,\n                              is: x =>\n                                  Object.values(def).filter(type => type.is(x))\n                                      .length > 0,\n                              case: (v, opts) => caseOf(def, v)(opts)\n                          })\n                      )\n              )\n              //   .andThen(Object.freeze)\n              .value()\n        : // wrong type definition\n          throwError('Union: Type definition must consist only of functions')\n\n//\n// -- Maybe Type --\n//\n\nconst AnyType = Type('Any', v => isNotNull(v))\nconst NothingType = Type('Nothing', v => !isNotNull(v), x => undefined)\n\n// const Just = Data('Any', { value: AnyType })\n// const Nothing = Data('Any', {})\n\nconst Maybe = Union('Maybe', {\n    // Just: Data('Just', { value: AnyType }),\n    // Nothing: Data('Nothing', { value: NothingType })\n    Just: AnyType,\n    Nothing: NothingType\n})\n\n//\n// -- Result Type --\n//\n\nconst SuccessType = Type(\n    'Ok',\n    v => isObject(v) && v.ok === true && AnyType.is(v.value),\n    v => ({ ok: true, value: AnyType(v) })\n)\nconst ErrorType = Type(\n    'Error',\n    v => isObject(v) && v.ok === false && StringType.is(v.error),\n    v => ({ ok: false, error: String(v) })\n)\nconst Result = Union('Result', {\n    Ok: SuccessType,\n    Err: ErrorType\n})\n\n//\nmodule.exports = {\n    Type,\n    Data, // Type\n    Union,\n    Maybe,\n    Result,\n\n    // Typechecked primitive type counterparts\n    String: StringType,\n    Object: ObjectType,\n    Number: NumberType,\n    Boolean: BooleanType,\n    Array: ArrayType,\n    Any: AnyType,\n    Nothing: NothingType,\n    Success: SuccessType,\n    Error: ErrorType\n}\n\n/*\n\nconst { Maybe } = require(\"./type.js\")\n\nconst j = Maybe.Just(\"Hey Ho!\")\nconst n = Maybe.Nothing()\n\nMaybe.case(j, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\nMaybe.case(n, {\n    Just: (v) => console.log(\"Just: \", v),\n    Nothing: (v) => console.log(\"Nothing: \", v)\n})\n\n\nconst { Result } = require(\"./type.js\")\n\nconst a = Result.Ok({ Some: \"Data\" })\na\nconst e = Result.Err(\"Oje Oje..\")\ne\n\n\n\nconst Type = require(\"./type.js\")\n\nconst Coord = Type.Type('Coord', Type.Number.is)\nCoord.toString()\nCoord.name\nconst c = Coord(23)\nc\nCoord.is(c)\n\nconst Point = Type.Data(\"Point\", { x: Coord, y: Coord, z: Number })\nPoint.toString()\nPoint.name\nconst p = Point({ x: 1, y: 1, z: 1 })\np\nPoint.is(p)\n\nconst Space = Type.Union(\"Space\", {\n    Planet: Point,\n    SolarSystem: Point\n})\nSpace.toString()\nconst s = Space.Planet(p)\ns\ns.toString()\nSpace.is(s)\n\nSpace.case(s, {\n    Planet: (s) => \"It's a planet\",\n    SolarSystem: (s) => \"It's a solar system\"\n})\n\n// s.case({\n//     Planet: (s) => console.log(\"It's a planet\"),\n//     SolarSystem: (s) => console.log(\"It's a solar system\")\n// })\n\n\n*/\n"]}